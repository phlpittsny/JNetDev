/****************************************************************************
**
** Copyright (C) 2005 Peter H. Lutz. All rights reserved.
**
** This file is part of the jNetDev network development system.
**
** This file may be used under the terms of the GNU General Public
** License version 2.0 as published by the Free Software Foundation
** and appearing in the file LICENSE included in the packaging of
** this file.  Please review the LICENSE file to ensure that GNU
** General Public Licensing requirements are met
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/
package jNetDev.Headers;
import jNetDev.*;
import java.io.*;

/** 
 * jND_ICMPv4 <br>
 * Class to model an ICMP version 4 header. Thi can be used to parse
 * a jND_IPv4 payload, or to build one for a new IPv4/ICMP packet.
 * <pre>
 * Basic header format:
 *
 *    +------------------------------------------------------------------+
 *    |      type      |      code      |             checkSum           |
 *    +-------8--------+--------8-------+----------------16--------------+
 *    |                                MORE                              |
 *    +------------------------------variable----------------------------+
 *
 * ICMP headers are among the most difficult to parse and build. This is
 * because there are several different header formats, depending on
 * the type field. The MORE field above represents the differing formats
 * that follow the common type, code, checksum header fields.
 * 
 * Following is a list of ICMP packet types available, and the additional
 * fields that they include.
 * 
 * Echo Reply (PING reply):  type = 0, code = 0
 * 
 * Data field format:
 *    +----------------+----------------+--------------------------------+
 *    |           identifier            |         sequenceNumber         |
 *    +-----------------16--------------+----------------16--------------+
 *    |                                data                              |
 *    +------------------------------variable----------------------------+
 *
 * The identifier is a unique number generated by the sender to whom we
 * are replying. The sequenceNumber is also sender generated and is used
 * to number the PINGs in a sequence of PINGs.
 * 
 * Destination unreachable: type = 3, code = error code
 * 
 * Data field format:
 *    +----------------+----------------+--------------------------------+
 *    |             unused              |            nextHopMTU          |
 *    +-----------------16--------------+----------------16--------------+
 *    |          returned (the IP header of the offending packet         |
 *    +------------------------------variable----------------------------+
 *    |  payload (first 8 bytes of IP payload of offending packet)       |
 *    +------------------------------variable----------------------------+
 *
 * Error codes:
 *      0   Network unreachable
 *      1   Host unreachable
 *      2   Protocol unreachable
 *      3   Port unreachable
 *      4   IP datagram too big
 *      5   Source route failed
 *      6   Destination network unknown
 *      7   Destination host unknown
 *      8   Obsolete
 *      9   Destination network administratively prohibited
 *     10   Destination host administratively prohibited
 *     11   Network unreachable for Type of Service
 *     12   Host unreachable for Type of Service
 *     13   Communication administratively prohibited
 *     14   Host precedence violation
 *     15   Precedence cutoff in effect.
 *
 * This is a message from a router to the effect that it could not deliver
 * the packet. The 'returned' field together with the 'data' field can be
 * parsed as a jND_IPv4 object. The 'data' will appear as the payload of
 * the packet in that case. The 'nextHopMTU' is an indication of the max
 * packet size allowed on the out link of the router when the forwarding
 * failed.
 * 
 * Source Quench:  type = 4, code = 0
 * 
 * Data field format:
 *    +------------------------------------------------------------------+
 *    |                              unused                              |
 *    +--------------------------------32--------------------------------+
 *    |          returned (the IP header of the offending packet         |
 *    +------------------------------variable----------------------------+
 *    |   payload (first 8 bytes of IP payload of offending packet)      |
 *    +------------------------------variable----------------------------+
 *
 * These packets are sent by routers to slow the flow of traffic. When a
 * router receives a source quench, it means the packet (whose header and
 * first 8 bytes of data are in 'returned' and 'data') was not delivered
 * and an indication that packet flow to that router should be slowed.
 *
 * The 'returned' and 'data' fields together can be parsed as a jND_IPv4
 * object.
 * 
 * Redirect:  type = 5, code = reason code
 * 
 * Data field format:
 *    +------------------------------------------------------------------+
 *    |               router (IP address of router to use)               |
 *    +--------------------------------32--------------------------------+
 *    |          returned (the IP header of the offending packet         |
 *    +------------------------------variable----------------------------+
 *    |  payload (first 8 bytes of IP payload of offending packet)       |
 *    +------------------------------variable----------------------------+
 *
 * Reason codes:
 *      0   Redirect for network error
 *      1   Redirect for host error
 *      2   Redirect for Type Of Service and network error
 *      3   Redirect for Type Of Service and host error
 *
 * This is an indication that the router who is returning this packet feels 
 * that there is a better route to the destination host. The packet WAS
 * forwarded, but future packets to this host should be sent to the router
 * whose IP address is in the 'router' field.
 *
 * The 'returned' and 'data' fields together can be parsed as a jND_IPv4
 * object.
 * 
 * Echo Request (PING request):  type = 8, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *    |                              payload                             |
 *    +------------------------------variable----------------------------+
 *
 * This is what a PING sender sends to a destination to determine if it is
 * alive. The identifier is a unique number that is returned in the replies.
 * It is used to distinguish this sequence of PINGs from others, if there are
 * multiple PINGs happening at the same time. The sequenceNumber usually
 * starts at 1 and is incremented on each PING packet in this series. The
 * 'data' field is simply garbage data that is echoed back to you. Its purpose
 * is to fill the packet up to the minimum required for the link.
 * 
 * Router Advertisement:  type = 9, code = advertisement type
 * 
 * Data field format:
 *    +----------------+----------------+--------------------------------+
 *    |      count     |      size      |                ttl             |
 *    +--------8----------------8-------+----------------16--------------+
 *    |               router (IP address of router to use)               | \
 *    +---------------------------------32-------------------------------+   'count' of
 *    |                          preferenceLevel                         | / these pairs
 *    +---------------------------------32-------------------------------+
 *
 * Advertisement types:
 *      0   Normal router advertisement
 *     16   Does not route common traffic
 *
 * This packet is sent from a router in reply to a Router Solicitation (below).
 * The count is the number of router entries. The size is the number of 32-bit
 * words per entry (usually this is 2 for an IP address and preferenceLevel).
 * The TTL is the amount of time, in seconds, that the entries are to be
 * considered valid.
 *
 * Following this come 'count' entries. Each contains a 4-octet IP address
 * plus a 4-octet preference level.
 * 
 * Router Solicitation:  type = 10, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |                             reserved                             |
 *    +---------------------------------32-------------------------------+
 *
 * The 'reserved' field is normally set to 0. This is a request for router
 * advertisements.
 * 
 * Time Exceeded:  type = 11, code = reason code
 * 
 * Data field format:
 *    +------------------------------------------------------------------+
 *    |                              unused                              |
 *    +--------------------------------32--------------------------------+
 *    |          returned (the IP header of the offending packet         |
 *    +------------------------------variable----------------------------+
 *    |  payload (first 8 bytes of IP payload of offending packet)       |
 *    +------------------------------variable----------------------------+
 *
 * Reason codes:
 *      0   TTL = 0 during transit
 *      1   Fragment reassembly timeout
 *
 * This is a notification from a router that some timeout occurred which
 * resulted in discarding a packet. The 'code' field indicates, as above, 
 * why the timeout occurred. The 'returned' and 'data' fields may be
 * parsed as a jND_IPv4 object to see what packet was discarded.
 * 
 * Parameter Problem:  type = 12, code = reason code
 * 
 * Data field format:
 *    +----------------+-------------------------------------------------+
 *    |     pointer    |                      unused                     |
 *    +-------8--------+------------------------24-----------------------+
 *    |          returned (the IP header of the offending packet         |
 *    +------------------------------variable----------------------------+
 *    |  payload (first 8 bytes of IP payload of offending packet)       |
 *    +------------------------------variable----------------------------+
 *
 * Reason codes:
 *      0   IP header invalid
 *      1   Required option missing
 *
 * This is a message from a router that there was a problem with a parameter
 * in an IP packet and that the packet was discarded. The 'code' field 
 * indicates, as per the above table, what the problem was. If the code is
 * 0, the 'ppointer' field is the offset into the 'returned' header of
 * where the problem occurred.
 *
 * The 'returned' and 'data' fields together may be parsed as a jND_IPv4 object.
 * 
 * Time Stamp Request:  type = 13, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *    |                         originateTimestamp                       |
 *    +---------------------------------32-------------------------------+
 *    |                          receiveTimestamp                        |
 *    +---------------------------------32-------------------------------+
 *    |                         transmitTimestamp                        |
 *    +---------------------------------32-------------------------------+
 *
 * Together with the Time Stamp Reply (below) this is used to indicate the
 * round trip time to a host. The identifier and sequenceNumber fields 
 * serve the same purpose as in a PING exchange. In the Time Stamp Request,
 * the originateTimestamp is set to the # of milliseconds since midnight UT
 * that when the sender last 'touched' the packet before sending it. The
 * other two timestamps are 0 and are filled in in the reply.
 * 
 * Time Stamp Reply:  type = 14, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *    |                         originateTimestamp                       |
 *    +---------------------------------32-------------------------------+
 *    |                          receiveTimestamp                        |
 *    +---------------------------------32-------------------------------+
 *    |                         transmitTimestamp                        |
 *    +---------------------------------32-------------------------------+
 *
 * This is a reply to a Time Stamp Request. The identifier, sequenceNumber,
 * and originateTimestamp fields are simply echos of those in the Time Stamp
 * Request. The receiveTimestamp is the time (since UT midnight) when the
 * receiver first touched the packet. The transmitTimestamp is the time that
 * the receiver last touched the packet before sending.
 * 
 * Address Mask Request:  type = 17, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *    |                           addressMask                            |
 *    +---------------------------------32-------------------------------+
 *
 * This packet is used to request from a host its submet mask. The identifier
 * and sequenceNumber packets operate as in a PING. The 'addressMask' field
 * is 0 in the request and filled in in the reply.
 * 
 * Address Mask Reply:  type = 18, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *    |                            addressMask                           |
 *    +---------------------------------32-------------------------------+
 *
 * This is a reply to an Address Mask Request. The 'addressMask' field is
 * filled in with the sender's netMask.
 * 
 * Traceroute:  type = 30, code = reason code
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |              unused            |
 *    +-----------------16--------------+----------------16--------------+
 *    |         outboundHopCount        |         returnHopCount         |
 *    +---------------------------------32-------------------------------+
 *    |                           outputLinkSpeed                        |
 *    +---------------------------------32-------------------------------+
 *    |                            outputLinkMTU                         |
 *    +---------------------------------32-------------------------------+
 *
 * Reason codes:
 *      0   Outbound packet successfully forwarded
 *      1   No route for outbound packet, discarded
 *
 * This packet is sent in response to an IP packet with the Traceroute option
 * set. The 'code' indicates the result of the trace route attempt. The 'identifier'
 * field is that in the 'ICMP Traceroute' option of the IP packet causing this
 * reply. Similarly, the outboundHopCount and returnHopCount are copied from
 * those options in the IP header of the packet causing this reply.
 *
 * The outputLinkSpeed is the transmission speed in bytes/second of the link
 * over which the sender sent this packet. The outputLinkMTU is the Maximum
 * Transmission Unit size of that same link.
 * 
 * Conversion Error:  type = 31, code = reason code
 * 
 * Data field format:
 *    +------------------------------------------------------------------+
 *    |                             dataOffset                           |
 *    +---------------------------------32-------------------------------+
 *    |                              payload                             |
 *    +------------------------------variable----------------------------+
 *
 * Reason codes:
 *      0   Unknown error
 *      1   Do not convert option present
 *      2   Unknown mandatory option present
 *      3   Known unsupported option present
 *      4   Unsupported transport protocol
 *      5   Overall length exceeded
 *      6   IP header length exceeded
 *      7   Transport protocol > 255
 *      8   Port conversion out of range
 *      9   Transport header length exceeded
 *     10   32-bit rollover missing and ACK set
 *     11   Unknown mandatory transport option present
 *
 * This indicates that a router could not perform a network layer packet
 * conversion. The reason for the failure is in the 'code' field. The 'data' 
 * field contains part of the packet that contained the problem.
 * 
 * Domain Name Request:  type = 37, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *
 * The identifier and sequenceNumber fields work as in a PING. This is a request
 * for the domain names known by a router/host.
 * 
 * Domain Name Reply:  type = 38, code = 0
 * 
 * Data field format:
 *    +---------------------------------+--------------------------------+
 *    |           identifier            |          sequenceNumber        |
 *    +-----------------16--------------+----------------16--------------+
 *    |                                ttl                               |
 *    +---------------------------------32-------------------------------+
 *    |                          payload (names)                         |
 *    +------------------------------variable----------------------------+
 *
 * The identifier and sequenceNumber fields work as in a PING. The ttl is the
 * number of seconds to trust these replies. The data field contains one or
 * more fully qualified domain names.
 * </pre>
 * As with all of the header modeling classes, this one contains 
 * accessors and mutators for each field, plus the two key methods:
 * parse and build.
 * <br><br>
 * Accessors are methods named
 * for each field which return the value of that field in the header
 * being manipulated. Accessors take no parameters, they allow the
 * user to "access" a field.
 * <br><br>
 * Mutators return no value. Instead, they take a parameter which is
 * the new value of a field in the header. Mutators allow the user
 * to change ("mutate") a field.
 * <br><br>
 * The parse method accepts a byte array (byte[])
 * and an integer offset into that byte array (defaults to 0) where
 * the header begins. It then separates out the fields into instance
 * variables that can be retrieved with the accessors. parse returns no
 * value.
 * <br><br>
 * The build method requires no parameters. It builds a byte array
 * from the instance variables for the fields and returns that byte
 * array as the result of the call.
 * <br><br>
 * @author Pete Lutz
 */

public class jND_ICMP {
	private int headerOffset;
	private int payloadOffset;
	
	private jND_BYTE1 typeNo;
	private jND_BYTE1 codeNo;
	private jND_BYTE2 checkSumNo;
    
	private jND_BYTE2 identifierNo;
	private jND_BYTE2 sequenceNumberNo;
    
	private jND_BYTE4 unusedNo;
	private jND_BYTE2 nextHopMTUNo;
    
	private jND_IPv4 returnedVal;          
	private jND_IPv4Address routerVal;
    
	private jND_BYTE4 reservedNo;
	private jND_BYTE4 preferenceLevelNo;
	private jND_BYTE1 countNo;
	private jND_BYTE1 sizeNo;
	private jND_BYTE4 ttlNo;
    
	private jND_BYTE4 originateTimestampNo;
	private jND_BYTE4 receiveTimestampNo;
	private jND_BYTE4 transmitTimestampNo;
	private jND_IPv4Address addressMaskVal;
    
	private jND_BYTE2 outboundHopCountNo;
	private jND_BYTE2 returnHopCountNo;
	private jND_BYTE1 pointerNo;
	private jND_BYTE4 outputLinkSpeedNo;
	private jND_BYTE4 outputLinkMTUNo;
	private jND_BYTE4 dataOffsetNo;

	private byte[] pload;

	public static final byte T_PING_REPLY = 0; 
	public static final byte T_DESTINATION_UNREACHABLE = 3;
		public static final byte C_UNREACHABLE_NETWORK = 0;
		public static final byte C_UNREACHABLE_HOST = 1;
		public static final byte C_UNREACHABLE_PROTOCOL = 2;
		public static final byte C_UNREACHABLE_PORT = 3;
		public static final byte C_UNREACHABLE_IP_DGRAM_TOO_BIG = 4;
		public static final byte C_UNREACHABLE_SOURCE_ROUTE_FAILED = 5;
		public static final byte C_UNREACHABLE_NETWORK_UNKNOWN = 6;
		public static final byte C_UNREACHABLE_HOST_UNKNOWN = 7;
		public static final byte C_UNREACHABLE_NETWORK_PROHIBITED = 9;
		public static final byte C_UNREACHABLE_HOST_PROHIBITED = 10;
		public static final byte C_UNREACHABLE_NETWORK_TOS = 11;
		public static final byte C_UNREACHABLE_HOST_TOS = 12;
		public static final byte C_UNREACHABLE_COMMUNICATION_PROHIBITED = 13;
		public static final byte C_UNREACHABLE_HOST_PRECEDENCE = 14;
		public static final byte C_UNREACHABLE_PRECEDENCE_CUTOFF = 15;
	public static final byte T_SOURCE_QUENCH = 4;
	public static final byte T_REASON_CODE = 5;
		public static final byte C_REASON_REDIRECT_NETWORK_ERROR = 0;
		public static final byte C_REASON_REDIRECT_HOST_ERROR = 1;
		public static final byte C_REASON_REDIRECT_TOS_NETWORK_ERROR = 2;
		public static final byte C_REASON_REDIRECT_TOS_HOST_ERROR = 3;
	public static final byte T_PING_REQUEST = 8;
	public static final byte T_ROUTER_ADVERTISEMENT = 9;
		public static final byte C_ROUTER_NORMAL = 0;
		public static final byte C_ROUTER_DOES_NOT_ROUTE_COMMON_TRAFFIC = 16;
	public static final byte T_ROUTER_SOLITICATION = 10;
	public static final byte T_TIME_EXCEEDED = 11;
		public static final byte C_TIME_TTL = 0;
		public static final byte C_TIME_REASSEMBLY = 1;
	public static final byte T_PARAMETER_PROBLEM = 12;
		public static final byte C_PARAMETER_BAD_IP_HEADER = 0;
		public static final byte C_PARAMETER_MISSING_OPTION = 1;
	public static final byte T_TIME_STAMP_REQUEST = 13;
	public static final byte T_TIME_STAMP_REPLY = 14;
	public static final byte T_ADDRESS_MASK_REQUEST = 17;
	public static final byte T_ADDRESS_MASK_REPLY = 18;
	public static final byte T_TRACEROUTE = 30;
		public static final byte C_TRACEROUTE_SUCCESS = 0;
		public static final byte C_TRACEROUTE_NOROUTE = 1;
	public static final byte T_CONVERSION_ERROR = 31;
		public static final byte C_CONVERSION_UNKNOWN = 0;
		public static final byte C_CONVERSION_DO_NOT_CONVERT = 1;
		public static final byte C_CONVERSION_UNKNOWN_OPTION = 2;
		public static final byte C_CONVERSION_UNSUPPORTED_OPTION = 3;
		public static final byte C_CONVERSION_UNSUPPORTED_TRANSPORT = 4;
		public static final byte C_CONVERSION_OVERALL_LENGTH = 5;
		public static final byte C_CONVERSION_IP_HEADER_LENGTH = 6;
		public static final byte C_CONVERSION_TRANSPORT_GT_255 = 7;
		public static final byte C_CONVERSION_PORT = 8;
		public static final byte C_CONVERSION_TRANSPORT_HEADER_LENGTH = 9;
		public static final byte C_CONVERSION_ROLLOVER_MISSING = 10;
		public static final byte C_CONVERSION_UNKNOWN_TRANSPORT_OPTION = 11;
	public static final byte T_DOMAINNAME_REQUEST = 37;
	public static final byte T_DOMAINNAME_REPLY = 38;

	/**
	 * Construct an empty ICMP packet.
	 * @author	Pete Lutz
	 */
	public jND_ICMP() {
		try {
			headerOffset = -1;
			payloadOffset = -1;
			
			typeNo = new jND_BYTE1(0);
			codeNo = new jND_BYTE1(0);
			checkSumNo = new jND_BYTE2(0);
		    
			identifierNo = new jND_BYTE2(0);
			sequenceNumberNo = new jND_BYTE2(0);
		    
			unusedNo = new jND_BYTE4(0);
			nextHopMTUNo = new jND_BYTE2(0);
		    
		    // returnedVal is a default constructed jND_IPv4
			returnedVal = new jND_IPv4();
		    // routerVal is a default constructed jND_IPv4Address
			routerVal = new jND_IPv4Address();
		    
			reservedNo = new jND_BYTE4(0);
			preferenceLevelNo = new jND_BYTE4(0);
			countNo = new jND_BYTE1(0);
			sizeNo = new jND_BYTE1(0);
			ttlNo = new jND_BYTE4(0);
		    
			originateTimestampNo = new jND_BYTE4(0);
			receiveTimestampNo = new jND_BYTE4(0);
			transmitTimestampNo = new jND_BYTE4(0);			
			// addressMask is an default constructed jND_IPv4Address
			addressMaskVal = new jND_IPv4Address();
		    
			outboundHopCountNo = new jND_BYTE2(0);
			returnHopCountNo = new jND_BYTE2(0);
			pointerNo = new jND_BYTE1(0);
			outputLinkSpeedNo = new jND_BYTE4(0);
			outputLinkMTUNo = new jND_BYTE4(0);
			dataOffsetNo = new jND_BYTE4(0);
		    

			pload = null;
		} catch(jND_Exception nde) {
			throw nde;
		} catch (Exception e) {
			throw new jND_Exception("jND_ICMP.constructor : " + e.toString());
		}
	}

	/**
	 * Method to retrieve the type field of the ICMP header.
	 * @return		The ICMP type as a 1-byte integer.
	 * @author	Pete Lutz
	 */
	public jND_BYTE1 type()  {
		return typeNo;
	}

	/**
	 * Method to set the type field of the ICMP header.
	 * @param		type - The ICMP type as a 1-byte integer.
	 * @author	Pete Lutz
	 */
	public void type(jND_BYTE1 type) {
		typeNo = type;
	}

	/**
	 * Method to retrieve the code field of the ICMP header.
	 * @return		The ICMP code as a 1-byte integer.
	 * @author	Pete Lutz
	 */
	public jND_BYTE1 code()  {
		return codeNo;
	}

	/**
	 * Method to set the code field of the ICMP header.
	 * @param		code - The ICMP code as a 1-byte integer
	 * @author	Pete Lutz
	 */
	public void code(jND_BYTE1 code) {
		codeNo = code;
	}

	/**
	 * Method to retrieve the check sum field of the ICMP header.
	 * @return		The ICMP check sum as a 2-byte integer.
	 * @author	Pete Lutz
	 */
	public jND_BYTE2 checkSum()  {
		return checkSumNo;
	}

	/**
	 * Method to set the check sum field of the ICMP header.
	 * Note: the checksum is calculated when build() is called,
	 * so setting this field has no real effect.
	 * @param		cksum - The ICMP check sum as a 2-byte integer
	 * @author	Pete Lutz
	 */
	public void checkSum(jND_BYTE2 cksum) {
		checkSumNo = cksum;
	}

	/**
	 * Method to retrieve the identifier field of the ICMP header.
	 * @return		The identifier for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_BYTE2 identifier()  {
		return identifierNo;
	}

	/**
	 * Method to set the identifier field of the ICMP header.
	 * @author	Pete Lutz
	 */
	public void identifier(jND_BYTE2 id) {
		identifierNo = id;
	}

	/**
	 * Method to retrieve the sequence number field of the ICMP header.
	 * @return		The sequence number for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_BYTE2 sequenceNumber()  {
		return sequenceNumberNo;
	}

	/**
	 * Method to set the sequence number field of the ICMP header.
	 * @param		seq - The sequence number for packets with this field.
	 * @author	Pete Lutz
	 */
	public void sequenceNumber(jND_BYTE2 seq) {
		sequenceNumberNo = seq;
	}

	/**
	 * Method to retrieve the unused field of the ICMP header.
	 * @return		The unused field for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 unused()  {
		return unusedNo;
	}

	/**
	 * Method to set the unused field of the ICMP header.
	 * @param		unused - The unused field for packets with this field.
	 * @author	Pete Lutz
	 */
	public void unused(jND_BYTE4 unused) {
		unusedNo = unused;
	}

	/**
	 * Method to retrieve the next hop MTU.
	 * @return		The next hop MTU for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_BYTE2 nextHopMTU()  {
		return nextHopMTUNo;
	}

	/**
	 * Method to set the next hop MTU.
	 * @param		nextHopMTU - The next hop MTU for packets with this field.
	 * @author	Pete Lutz
	 */
	public void nextHopMTU(jND_BYTE2 nextHopMTU) {
		nextHopMTUNo = nextHopMTU;
	}

	/**
	 * Method to retrieve a returned IP header.
	 * @return		The returned IP header for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_IPv4 returned()  {
		return returnedVal;
	}
	
	/**
	 * Method to set a returned IP header.
	 * @author	Pete Lutz
	 */
	public void returned(jND_IPv4 ipHdr) {
		returnedVal = ipHdr;
	}

	/**
	 * Method to retrieve the router IP address field.
	 * @return		The router IP of a redirect or advertisement.
	 * @author	Pete Lutz
	 */
	public jND_IPv4Address router()  {
		return routerVal;
	}

	/**
	 * Method to set the router IP address field.
	 * @param		routerIP - The router IP of a redirect or advertisement.
	 * @author	Pete Lutz
	 */
	public void router(jND_IPv4Address routerIP) {
		routerVal = routerIP;
	}

	/**
	 * Method to retrieve the reserved field of the ICMP header.
	 * @return		The reserved field for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 reserved()  {
		return reservedNo;
	}

	/**
	 * Method to set the reserved field of the ICMP header.
	 * @param		reserved - The reserved field for packets with this field.
	 * @author	Pete Lutz
	 */
	public void reserved(jND_BYTE4 reserved) {
		reservedNo = reserved;
	}

	/**
	 * Method to retrieve the preference level field of the ICMP header.
	 * @return		The preference level in a router advertisement.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 preferenceLevel()  {
		return preferenceLevelNo;
	}

	/**
	 * Method to set the preference level field of the ICMP header.
	 * @param		pref - The preference level in a router advertisement.
	 * @author	Pete Lutz
	 */
	public void preferenceLevel(jND_BYTE4 pref) {
		preferenceLevelNo = pref;
	}

	/**
	 * Method to retrieve the count field of the ICMP header.
	 * @return		The count field from a router advertisement.
	 * @author	Pete Lutz
	 */
	public jND_BYTE1 count()  {
		return countNo;
	}

	/**
	 * Method to set the count field of the ICMP header.
	 * @param		count - The count field from a router advertisement.
	 * @author	Pete Lutz
	 */
	public void count(jND_BYTE1 count) {
		countNo = count;
	}

	/**
	 * Method to retrieve the size field of the ICMP header.
	 * @return		The size field of a router advertisement.
	 * @author	Pete Lutz
	 */
	public jND_BYTE1 size()  {
		return sizeNo;
	}

	/**
	 * Method to set the size field of the ICMP header.
	 * @param		size - The size field of a router advertisement.
	 * @author	Pete Lutz
	 */
	public void size(jND_BYTE1 size) {
		sizeNo = size;
	}

	/**
	 * Method to retrieve the TTL field of the ICMP header.
	 * @return		The Time To Live for packets with this field.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 ttl()  {
		return ttlNo;
	}

	/**
	 * Method to set the TTL field of the ICMP header.
	 * @param		ttl - The Time To Live for packets with this field.
	 * @author	Pete Lutz
	 */
	public void ttl(jND_BYTE4 ttl) {
		ttlNo = ttl;
	}

	/**
	 * Method to retrieve the originate time stamp field of the ICMP header.
	 * @return		The originate time stampe for Time Stamp 
	 * Request/Reply packets.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 originateTimestamp()  {
		return originateTimestampNo;
	}

	/**
	 * Method to set the originate time stamp field of the ICMP header.
	 * @param		timeStamp - The originate time stampe for Time Stamp 
	 * Request/Reply packets.
	 * @author	Pete Lutz
	 */
	public void originateTimestamp(jND_BYTE4 timeStamp) {
		originateTimestampNo = timeStamp;
	}

	/**
	 * Method to retrieve the receive time stamp field of the ICMP header.
	 * @return		The receive time stampe for Time Stamp 
	 * Request/Reply packets.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 receiveTimestamp()  {
		return receiveTimestampNo;
	}

	/**
	 * Method to set the receive time stamp field of the ICMP header.
	 * @param		timeStamp - The receive time stampe for Time Stamp 
	 * Request/Reply packets.
	 * @author	Pete Lutz
	 */
	public void receiveTimestamp(jND_BYTE4 timeStamp) {
		receiveTimestampNo = timeStamp;
	}

	/**
	 * Method to retrieve the transmit time stamp field of the ICMP header.
	 * @return		The transmit time stampe for Time Stamp 
	 * Request/Reply packets.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 transmitTimestamp()  {
		return transmitTimestampNo;
	}

	/**
	 * Method to set the transmit time stamp field of the ICMP header.
	 * @param		timeStamp - The transmit time stampe for Time Stamp 
	 * Request/Reply packets.
	 * @author	Pete Lutz
	 */
	public void transmitTimestamp(jND_BYTE4 timeStamp) {
		transmitTimestampNo = timeStamp;
	}

	/**
	 * Method to retrieve the address mask field of the ICMP header.
	 * @return		The address mask from an address mask reply packet.
	 * @author	Pete Lutz
	 */
	public jND_IPv4Address addressMask()  {
		return addressMaskVal;
	}

	/**
	 * Method to set the address mask field of the ICMP header.
	 * @param		mask - The address mask from an address mask reply packet.
	 * @author	Pete Lutz
	 */
	public void addressMask(jND_IPv4Address mask) {
		addressMaskVal = mask;
	}

	/**
	 * Method to retrieve the outbound hop count field of the ICMP header.
	 * @return		The outbound hop count from a trace route reply packet.
	 * @author	Pete Lutz
	 */
	public jND_BYTE2 outboundHopCount()  {
		return outboundHopCountNo;
	}

	/**
	 * Method to set the outbound hop count field of the ICMP header.
	 * @param		hops - The outbound hop count from a trace route reply packet.
	 * @author	Pete Lutz
	 */
	public void outboundHopCount(jND_BYTE2 hops) {
		outboundHopCountNo = hops;
	}

	/**
	 * Method to retrieve the return hop count field of the ICMP header.
	 * @return		The return hop count from a trace route reply packet.
	 * @author	Pete Lutz
	 */
	public jND_BYTE2 returnHopCount()  {
		return returnHopCountNo;
	}

	/**
	 * Method to set the return hop count field of the ICMP header.
	 * @param		hops - The return hop count from a trace route reply packet.
	 * @author	Pete Lutz
	 */
	public void returnHopCount(jND_BYTE2 hops) {
		returnHopCountNo = hops;
	}

	/**
	 * Method to retrieve the pointer field from a Parameter Problem packet.
	 * @return		The pointer value.
	 * @author	Pete Lutz
	 */
	public jND_BYTE1 pointer()  {
		return pointerNo;
	}

	/**
	 * Method to set the pointer field from a Parameter Problem packet.
	 * @param		ptr - The pointer value.
	 * @author	Pete Lutz
	 */
	public void pointer(jND_BYTE1 ptr) {
		pointerNo = ptr;
	}

	/**
	 * Method to retrieve the output link speed from a Trace Route reply.
	 * @return		The link speed in bytes/second.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 outputLinkSpeed()  {
		return outputLinkSpeedNo;
	}

	/**
	 * Method to set the output link speed from a Trace Route reply.
	 * @param		linkSpeed - The link speed in bytes/second.
	 * @author	Pete Lutz
	 */
	public void outputLinkSpeed(jND_BYTE4 linkSpeed) {
		outputLinkSpeedNo = linkSpeed;
	}

	/**
	 * Method to retrieve the output link MTU from a Trace Route reply.
	 * @return		The MTU in bytes.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 outputLinkMTU()  {
		return outputLinkMTUNo;
	}

	/**
	 * Method to set the output link MTU from a Trace Route reply.
	 * @param		linkMTU - The MTU in bytes.
	 * @author	Pete Lutz
	 */
	public void outputLinkMTU(jND_BYTE4 linkMTU) {
		outputLinkMTUNo = linkMTU;
	}

	/**
	 * Method to retrieve the data offset field from a conversion error packet.
	 * @return		The data offset.
	 * @author	Pete Lutz
	 */
	public jND_BYTE4 dataOffset()  {
		return dataOffsetNo;
	}

	/**
	 * Method to set the data offset field from a conversion error packet.
	 * @param		offset - The data offset.
	 * @author	Pete Lutz
	 */
	public void dataOffset(jND_BYTE4 offset) {
		dataOffsetNo = offset;
	}

	/**
	 * Method to retrieve the payload field of the ICMP header.
	 * @return		The payload (referred to as 'data' in the
	 * header format.
	 * @author	Pete Lutz
	 */
	public byte[] payload()  {
		return pload;
	}

	/**
	 * Method to set the payload field of the ICMP header.
	 * @param		pload - The payload (referred to as 'data' in the 
	 * header format.
	 * @author	Pete Lutz
	 */
	public void payload(byte[] pload) {
		this.pload = pload;
	}

	/**
	 * Method to parse an ICMP header into its parts. This is a
	 * convenience method equivalent to parse(pkt, 0)
	 * @param		pkt - the packet to parse
	 * @author	Pete Lutz
	 */
	public void parse(byte[] pkt) {
		parse(pkt, 0);
	}

	/**
	 * Method to parse an ICMP header into its parts.
	 * @param		pkt - the packet to parse
	 * @param		offset - where in the packet to start parsing.
	 * @author	Pete Lutz
	 */
	public void parse(byte[] pkt, int offset) {
		try {
			headerOffset = offset;
			byte[] tmpRouterVal = new byte[jND_IPv4Address.IP_ADDR_LEN];
			
			ByteArrayInputStream bais = new ByteArrayInputStream(pkt);
			DataInputStream pis = new DataInputStream(bais);
			pis.skipBytes(headerOffset);
		    
			typeNo = new jND_BYTE1(pis.readByte());
			codeNo = new jND_BYTE1(pis.readByte());
			checkSumNo = new jND_BYTE2(pis.readShort());

			long tmp;
		    
			switch(typeNo.toInt()) {
				// Ping req/reply
				case 0:
				case 8:
					identifierNo = new jND_BYTE2(pis.readShort());
					sequenceNumberNo = new jND_BYTE2(pis.readShort());
					if(offset+8 < pkt.length) {
						pload = new byte[pkt.length - (offset+8)];
						for(int i = 0; i < pload.length; i++) 
							pload[i] = pis.readByte();
					}
					break;
				case 3:
				case 4:
				case 5:
				case 11:
				case 12:
					// This 'unused' 4-byte field will be many
					// things depending on the code (3, 4, 5, 11 or 12)
					int unusedTmp = pis.readInt();
		            
					// Parse returned IP header
					// ..... Parse the rest of the ICMP packet as an IPDatagram
					returnedVal.parse(pkt, offset+8); 
		            
					if(returnedVal.payload().length > 0)
						pload = returnedVal.payload();

					// Now, parse the unusedTmp from above depending on type
					if(typeNo.toInt() == 3) {
						nextHopMTUNo = new jND_BYTE2(unusedTmp);
						unusedNo = new jND_BYTE4(unusedTmp >> 16);
					}
					else if(typeNo.toInt() == 5) {
						for(int i = 0; i < jND_IPv4Address.IP_ADDR_LEN; i++) {
							tmpRouterVal[i] = (byte)((unusedTmp >> 24) & 0xff);
							unusedTmp = unusedTmp << 8;
						}
						routerVal = new jND_IPv4Address(tmpRouterVal);
						unusedNo = new jND_BYTE4(0);
					}
					else if(typeNo.toInt() == 12) {
						pointerNo = new jND_BYTE1(unusedTmp >> 24);
						unusedNo = new jND_BYTE4(unusedTmp & 0xffffff);
					}
					break;  
				case 9:
					countNo = new jND_BYTE1(pis.readByte());
					sizeNo = new jND_BYTE1(pis.readByte());
					ttlNo = new jND_BYTE4(pis.readShort());

					tmp = pis.readInt();
					for(int i = 0; i < 4; i++) {
						tmpRouterVal[i] = (byte)((tmp >> 24) & 0xff);
						tmp = tmp << 8;
					}
					routerVal = new jND_IPv4Address(tmpRouterVal);

					preferenceLevelNo = new jND_BYTE4(pis.readInt());
					pload = new byte[pkt.length - (offset+16)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 10:
					reservedNo = new jND_BYTE4(pis.readInt());
					pload = new byte[pkt.length - (offset+16)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 13:
				case 14:
					identifierNo = new jND_BYTE2(pis.readShort());
					sequenceNumberNo = new jND_BYTE2(pis.readShort());
					originateTimestampNo = new jND_BYTE4(pis.readInt());
					receiveTimestampNo = new jND_BYTE4(pis.readInt());
					transmitTimestampNo = new jND_BYTE4(pis.readInt());
					pload = new byte[pkt.length - (offset+20)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 17:
				case 18:
					identifierNo = new jND_BYTE2(pis.readShort());
					sequenceNumberNo = new jND_BYTE2(pis.readShort());
					addressMaskVal = new jND_IPv4Address(new jND_BYTE4(pis.readInt()));
					pload= new byte[pkt.length - (offset+12)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 30:
					identifierNo = new jND_BYTE2(pis.readShort());
					unusedNo = new jND_BYTE4(pis.readShort());
					outboundHopCountNo = new jND_BYTE2(pis.readShort());
					returnHopCountNo = new jND_BYTE2(pis.readShort());
					outputLinkSpeedNo = new jND_BYTE4(pis.readInt());
					outputLinkMTUNo = new jND_BYTE4(pis.readInt());
					pload = new byte[pkt.length - (offset+20)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 31:
					dataOffsetNo = new jND_BYTE4(pis.readInt());
					pload = new byte[pkt.length - (offset+8)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 37:
					identifierNo = new jND_BYTE2(pis.readShort());
					sequenceNumberNo = new jND_BYTE2(pis.readShort());
					pload = new byte[pkt.length - (offset+8)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
				case 38:
					identifierNo = new jND_BYTE2(pis.readShort());
					sequenceNumberNo = new jND_BYTE2(pis.readShort());
					ttlNo = new jND_BYTE4(pis.readInt());
					pload = new byte[pkt.length - (offset+12)];
					for(int i = 0; i < pload.length; i++)
						pload[i] = pis.readByte();
					break;
			}
		} catch(jND_Exception nde) {
			throw nde;
		} catch (Exception e) {
			throw new jND_Exception("jND_ICMP.parse : " + e.toString());
		}
	}

	/**
	 * Method to build an ICMP header for sending from its parts.
	 * @return		a byte array which is the packet.
	 * @author	Pete Lutz
	 */
	public byte[] build(){
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			DataOutputStream pos = new DataOutputStream(baos);

			pos.writeByte(typeNo.toByte());
			pos.writeByte(codeNo.toByte());
			checkSumNo = new jND_BYTE2(0);	// To be calculated and replaced below
			pos.writeShort(checkSumNo.toShort());

			long tmp;
			byte[] retHdr;
		    
			switch(typeNo.toInt()) {
				case 0:
				case 8:
					pos.writeShort(identifierNo.toShort());
					pos.writeShort(sequenceNumberNo.toShort());
					break;
				case 3:
				case 4:
				case 5:
				case 11:
				case 12:
					tmp = 0;
					if(typeNo.toInt() == 3) 
						tmp = (unusedNo.toInt() << 16) | 
							(nextHopMTUNo.toInt());
					else if(typeNo.toInt() == 4 || typeNo.toInt() == 11) 
						tmp = unusedNo.toLong();
					else if(typeNo.toInt() == 5) {
						byte[] tmprv = routerVal.toByteArray();
						for(int i = 0; i < 4; i++) {
							tmp = tmp << 8;
							tmp = tmp | (tmprv[i] & 0xff);
						}
					}
					else if(typeNo.toInt() == 12) 
						tmp = (pointerNo.toByte() << 24) | (unusedNo.toInt() & 0xffffff);
					pos.writeInt((int)tmp);
					retHdr = returnedVal.build();
					// the +8 is because the 1st 8 bytes of the IP payload is
					// also to go. The header length is in 4-byte words, which
					// explains the *4
					for(int i = 0; i < returnedVal.headerLength().toInt()*4 + 8; i++)
						pos.writeByte(retHdr[i]);
					break;
				case 13:
				case 14:
					pos.writeShort(identifierNo.toShort());
					pos.writeShort(sequenceNumberNo.toShort());
					pos.writeInt(originateTimestampNo.toInt());
					pos.writeInt(receiveTimestampNo.toInt());
					pos.writeInt(transmitTimestampNo.toInt());
					break;
				case 17:
				case 18:
					pos.writeShort(identifierNo.toShort());
					pos.writeShort(sequenceNumberNo.toShort());
					pos.writeInt(addressMaskVal.toByte4().toInt());
					break;
				case 30:
					pos.writeShort(identifierNo.toShort());
					pos.writeShort(unusedNo.toShort());
					pos.writeShort(outboundHopCountNo.toShort());
					pos.writeShort(returnHopCountNo.toShort());
					pos.writeInt(outputLinkSpeedNo.toInt());
					pos.writeInt(outputLinkMTUNo.toInt());
					break;
				case 31:
					pos.writeInt(dataOffsetNo.toInt());
					break;
				case 37:
					pos.writeShort(identifierNo.toShort());
					pos.writeShort(sequenceNumberNo.toShort());
					break;
				case 38:
					pos.writeShort(identifierNo.toShort());
					pos.writeShort(sequenceNumberNo.toShort());
					pos.writeInt(ttlNo.toInt());
					break;                
			} 
			
			// The payload
			if(pload != null)
				for(int i = 0; i < pload.length; i++)
					pos.writeByte(pload[i]);
			
			pos.close();
			baos.close();
		    
			// Recalculate the checksum
			byte[] packet = baos.toByteArray();
			checkSumNo = new jND_BYTE2(
					jND_Utility.checkSum(packet, (int)(packet.length)));
			packet[2] = (byte)((checkSumNo.toInt() >> 8) & 0xff);
			packet[3] = (byte)(checkSumNo.toInt() & 0xff);
		    
			return packet;
		} catch(jND_Exception nde) {
			throw nde;
		} catch (Exception e) {
			throw new jND_Exception("jND_ICMP.build : " + e.toString());
		}
	}
};
